<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>
  <HEAD>
    <META name="generator" content=
    "HTML Tidy for Java (vers. 2009-12-01), see jtidy.sourceforge.net">
    <META http-equiv="Content-Language" content="en-us">
    <META http-equiv="Content-Type" content="text/html; charset=windows-1252">
    <META name="GENERATOR" content="Microsoft FrontPage 4.0">
    <META name="ProgId" content="FrontPage.Editor.Document">

    <TITLE>Decompiler</TITLE>
    <LINK rel="stylesheet" type="text/css" href="../../shared/Frontpage.css">
  </HEAD>

  <BODY>
    <H1><A name="Decompile_Function"></A>Decompiler</H1>

    <BLOCKQUOTE>
      <P>The Decompiler plugin is a sophisticated transformation engine which automatically
      converts the binary representation of individual functions into a high-level C
      representation. The Decompiler presents a view of a program which is interactive and
      dynamically updated as the user adds or makes changes to the annotations associated with the
      program. A Decompiler window maintains the correspondence between the C representation and
      the assembly representation displayed in the Code Browser window, to the extent possible. The
      window allows instant visual association and navigation between C language expressions and
      their corresponding assembly instructions.</P>

      <P>To display the decompiler window, position the cursor on a function in the Code Browser,
      then select the <IMG alt="" src="images/decompileFunction.gif" border="0"> icon from the tool
      bar, or the <B>Decompile</B> option from the <B>Window</B> menu in the tool.</P>

      <CENTER style="margin-top:50px; margin-bottom:25px">
        <P><IMG alt="" src="images/DecompWindow.png" border="0"></P>
      </CENTER>

      <P><A name="Capabilities"></A>Some of the primary capabilities of the decompiler include:</P>

      <UL>
        <LI><I><B>Recovers Expressions</B></I>: The decompiler does full dataflow analysis which
        allows it to perform slicing on functions. The most tangible benefit to the user is that
        complicated expressions, which have been split into distinct operations/instructions and
        then mixed together with other instructions by the compiling/optimizing process, are
        reconstituted into a single expression again by the decompiler.</LI>

        <LI><I><B>Recovers High-Level Scoped Variables</B></I>: The decompiler understands how
        compilers use processor stacks and registers to implement variables with different scopes
        within a function. Data-flow allows it to follow what was originally a single variable as it
        moves from the stack, into a register, into a different register, etc. Thus it can
        effectively recover the original programs concept of a variable, minimizing the need to
        introduce artificial variables in the output.</LI>

        <LI><I><B>Recovers Function Parameters</B></I>: The decompiler understands the parameter
        passing conventions of the compiler and can reconstruct the form of the original function
        call.</LI>

        <LI><I><B>Uses Data type, Name, and Signature Annotations</B></I>: The decompiler
        automatically pulls in all the different data types and variable names that the user has
        applied to functions, and the C output is altered to reflect this. High-level variables are
        appropriately named, structure fields and array indices are calculated and displayed with
        correct syntax, constant char pointers are replaced with appropriate quoted strings,
        etc.</LI>

        <LI><I><B>Performs Local Type Propagation</B></I>: In the absence of information, the
        decompiler does its best to fill in information from what it does know. Variables whose
        data type has not been explicitly labeled by the user can often by recovered by seeing how
        the variable is used or by allowing the known data types to propagate.</LI>

        <LI><SPAN style="font-weight: bold; font-style: italic;">Can be used to Automatically
        Recover Structure Fields</SPAN>:&nbsp; The decompiler can be leveraged to recover
        references to a structure.<BR>
        </LI>
      </UL>

      <H3><A name="Variables"></A>Variables</H3>

      <BLOCKQUOTE>
        <P>The decompiler will attempt to combine different locations (stack, memory, register) for
        variables within a function. Data type information for variables is gathered automatically
        from several sources. Any annotated function signatures, both of the function and of any
        sub-functions it calls, provide type information. If the function contains references to
        global memory locations that have a data type applied to them, these will also be used, and
        any local variables of the function can be annotated directly with data types. The user can
        provide data-type information to the decompiler by annotating all these sources. The more
        information that can be provided the better the produced C-code will be.</P>

        <P>Variables not labeled directly are assigned types by analyzing local type propagation.
        Typically, assigning data types to a few key variables dramatically improves the
        readability of the C-code, as propagation will accurately fill in all the other data types.
        Assigning types in function signatures and to global variables is particularly effective
        because of their effect across multiple functions simultaneously.</P>

        <P><IMG alt="" src="../../shared/note.png" border="0">If you have C-header files for an API
        a program is using, there is a prototype C-Code parser than can extract the Data Type
        information from C-Code and create a <A href=
        "help/topics/DataTypeManagerPlugin/data_type_manager_description.htm#Archives"><FONT color=
        "#ff0000">Ghidra Data Type Archive (.gdt)</FONT></A>. The interface is currently fairly
        crude, but it handles most C syntax including macro expansion. The function signatures and
        data types extracted can be applied to the program. Just <A href=
        "help/topics/DataTypeManagerPlugin/data_type_manager_description.htm#Open_File_Data_Type_Archive">open
        the archive</A> in the <I>Data Type Manager</I> window, select the archive, right mouse
        click, and select <B><A href=
        "help/topics/DataTypeManagerPlugin/data_type_manager_window.html#Apply_All">Apply
        Function DataTypes</A></B>. Ghidra currently provides definitions for the majority of
        windows API functions and data types automatically.</P>
      </BLOCKQUOTE>

      <H3><A name="Parameter_Variables"></A>Parameter Variables</H3>

      <BLOCKQUOTE>
        <P>Specifying data types for function parameters is especially useful. A function that has
        data types defined for its parameters will propagate these types into the variables of any
        calling functions.</P>

        <P>C variable argument conventions, or varargs, are are also supported. For instance, if
        the user has identified the standard C library routine <I>printf</I>, the signature can be
        defined to be void printf (char *, ...). Now whenever printf() is called, the decompiler
        will display the correct number of variable arguments.</P>

        <P>Function signatures can be applied from a Ghidra data type database. Windows data types
        and standard C library function signatures are included with the standard distribution.
        More definitions will be added in the future.<BR>
        </P>
      </BLOCKQUOTE>

      <H3><A name="Internal_Decompiler_Functions"></A>Internal Decompiler Functions</H3>

      <BLOCKQUOTE>
        <P>Occasionally, the decompiler may use one of several internal decompiler functions that
        don't get transformed into more 'C'-like expressions. Use of these can indicate that the
        pcode is incorrect or needs to be "Tuned" to make the decompiler output better. It can also
        mean that the decompiler needs an additional simplification rule to take care of that
        particular situation.<BR>
        </P>

        <UL>
          <LI><FONT color="#333399">SUB41(x,c)</FONT> - truncation operation</LI>

          <LI style="list-style-type: none; list-style-image: none; list-style-position: outside;">
            <DIV style="margin-left: 2em;">
              <UL>
                <LI>The 4 is the size of the input operand (x) in bytes.</LI>
              </UL>
            </DIV>

            <DIV style="margin-left: 2em;">
              <UL>
                <LI>The 1 is the size of the output value in bytes.</LI>

                <LI>The x is the thing being truncated</LI>

                <LI>The c is the number of least significant bytes being truncated<BR>
                </LI>
              </UL>
            </DIV>
          </LI>
        </UL>

        <BLOCKQUOTE>
          <BLOCKQUOTE>
            <P><FONT color="#009900">SUB42(0xaabbccdd,1) = 0xbbcc</FONT></P>

            <P>When "c" is 0, the operation is almost always a cast between integer sizes, where
            the decompiler didn't quite figure it out. Usually the decompiler didn't figure out
            that "x" was an integer type or was forced to assume otherwise.</P>

            <P>SUB41(x,0) is usually a cast from "int" to "char".<BR>
             SUB42(x,0) is a cast from "int" to "short" and so on.<BR>
             SUB84(x,4) is probably part of an extended precision multiplication but also turns up
            in other things like division strength reduction.<BR>
            </P>
          </BLOCKQUOTE>
        </BLOCKQUOTE>

        <UL>
          <LI><FONT color="#333399">CONCAT31(x,y)</FONT> - concatenates two operands together into
          a larger size object</LI>

          <LI style="list-style-type: none; list-style-image: none; list-style-position: outside;">
            <DIV style="margin-left: 2em;">
              <UL>
                <LI>The "3" is the size of x in bytes.</LI>

                <LI>The "1" is the size of y in bytes.</LI>

                <LI>The result is the 4-byte concatenation of the bits in "x" with the bits<BR>
                 in "y". The "x" forms the most signifigant part of the result, "y" the<BR>
                 least.</LI>
              </UL>
            </DIV>
          </LI>
        </UL>

        <BLOCKQUOTE>
          <BLOCKQUOTE>
            <P><FONT color="#009900">CONCAT31(0xaabbcc,0xdd) = 0xaabbccdd<BR>
            </FONT></P>

            <P>This usually crops up when a 1-byte sized (char) variable is being stored in a
            4-byte register. All the basic arithmetic/logical ops on the 4-byte register give the
            correct result for doing the operation on a 1-byte variable; the compiler just has to
            make sure to ignore the 3 most significant bytes of the register. The CONCAT31 is the
            decompiler keeping track of these most significant bytes that the compiler was ignoring
            because it is mistakenly interpreting the register variable as being a 4-byte variable.
            In many cases the decompiler can figure this out, but especially in looping constructs,
            it cannot. This is really a dead code issue. The decompiler currently makes judgements
            about dead code for entire varnodes. A full fix of this problem would require a dead
            code elimination algorithm that could decide if part of a varnode were dead.<BR>
            </P>
          </BLOCKQUOTE>
        </BLOCKQUOTE>

        <UL>
          <LI><FONT color="#333399">ZEXT14(x)</FONT> - zero extension</LI>

          <LI style="list-style-type: none; list-style-image: none; list-style-position: outside;">
            <DIV style="margin-left: 2em;">
              <UL>
                <LI>The 1 is the size of the operand x</LI>

                <LI>The 4 is the size of the output in bytes</LI>
              </UL>
            </DIV>
          </LI>
        </UL>

        <BLOCKQUOTE>
          <BLOCKQUOTE>
            <P>This is almost always a cast from small integer types to big unsigned types.</P>
          </BLOCKQUOTE>
        </BLOCKQUOTE>

        <UL>
          <LI><FONT color="#333399">SEXT14(x)</FONT> - signed extension</LI>

          <LI style="list-style-type: none; list-style-image: none; list-style-position: outside;">
            <DIV style="margin-left: 2em;">
              <UL>
                <LI>The 1 is the size of the operand x</LI>

                <LI>The 4 is the size of the output in bytes</LI>
              </UL>
            </DIV>
          </LI>
        </UL>

        <BLOCKQUOTE>
          <BLOCKQUOTE>
            <P>This is probably a cast from a small signed integer into a big signed integer.</P>
          </BLOCKQUOTE>
        </BLOCKQUOTE>

        <UL>
          <LI><FONT color="#333399">SBORROW4(x,y)</FONT> - true if subtracting the signed numbers
          would cause a borrow</LI>

          <LI style="list-style-type: none; list-style-image: none; list-style-position: outside;">
            <DIV style="margin-left: 2em;">
              <UL>
                <LI>The 4 is the size of both x and y in bytes</LI>
              </UL>
            </DIV>
          </LI>
        </UL>

        <BLOCKQUOTE>
          <BLOCKQUOTE>
            <P>Returns "true" if there is an arithmetic overflow when subtracting "y" from "x" as
            signed integers. These are generated particularly by signed integer comparisons. There
            are rules in place for recovering the original comparison, but this is a missed one
            special case. These could also conceivably be generated in extended precision
            subtraction.<BR>
            </P>
          </BLOCKQUOTE>
        </BLOCKQUOTE>

        <UL>
          <LI><FONT color="#333399">CARRY4(x,y)</FONT> - true if there would be a carry adding x to
          y</LI>

          <LI><FONT color="#333399">SCARRY4(x,y)</FONT> - true if there would be a signed overflow
          adding x to y<BR>
          </LI>

          <LI style="list-style-type: none; list-style-image: none; list-style-position: outside;">
            <DIV style="margin-left: 2em;">
              <UL>
                <LI>The 4 is the size of both x and y in bytes</LI>
              </UL>
            </DIV>
          </LI>
        </UL>

        <BLOCKQUOTE>
          <BLOCKQUOTE>
            <P>Returns "true" if there would be a carry adding x to y.</P>

            <P>If these are turning up everywhere in a particular binary, it could be a missed
            simplification that could be easily fixed.<BR>
            </P>
          </BLOCKQUOTE>
        </BLOCKQUOTE>
      </BLOCKQUOTE>

      <H3><A name="Register_Settings"></A>Register Settings</H3>

      <BLOCKQUOTE>
        <P>Occasionally a program will use a register to store a global constant. By using the
        <FONT color="#ff0000">&lt;Set Register&gt;</FONT> function on the right mouse pop-up menu,
        the user can specify this value to the decompiler. The constant will be propagated
        automatically throughout the function, and the resulting code may be greatly
        simplified.</P>
      </BLOCKQUOTE>

      <H3><A name="DecompileOptions"></A>Decompiler Options</H3>

      <BLOCKQUOTE>
        <P>The following Decompiler Analysis Options are available ( Edit-&gt;Options
        Decompiler/Analysis ):</P>

        <UL>
          <LI><SPAN style="font-weight: bold;">Eliminate unreachable code</SPAN> - causes the
          decompiler to eliminate branch paths which it considers unreachable as a result of
          constant propagation.<BR>
          <BR>
          </LI>

          <LI><SPAN style="font-weight: bold;">Ignore unimplemented instructions</SPAN> - causes
          the decompiler to ignore instructions whose semantics have been marked as
          unimplemented.&nbsp; Otherwise a <SPAN style=
          "font-style: italic;">halt_unimplemented</SPAN> call will appear in the decompilation for
          such cases.<BR>
          <BR>
          </LI>

          <LI><SPAN style="font-weight: bold;">Infer constant pointers</SPAN> - allows the decompiler
          to infer a data-type for constants it determines are likely pointers. In the basic heuristic,
          each constant is treated as an address, and if that address starts a known data or function element
          in the program, the constant is assumed to be a pointer.<BR>
          <BR>
          </LI>

          <LI><B>Respect read-only flags</B> - causes the decompiler to treat any values in memory
          or blocks of memory marked read-only as constant values. Normally global memory is
          considered public writable, meaning you cannot depend on the initial value at a location.
          Any global value could be changed by another function.&nbsp; For areas of memory that are
          really read-only and never change their statically initialized value, mark the memory
          area as read only in the <I>Memory Manager</I> or specific Data locations as <SPAN style=
          "font-style: italic;">Constant</SPAN> (see Data Mutability below).<BR>
          <BR>
           Typically as part of the import process, memory blocks are marked as read-only if the
          memory block is tagged as such in the imported binary.<BR>
          <BR>
          </LI>

          <LI><SPAN style="font-weight: bold;">Simplify predication</SPAN> - causes the decompiler
          to simplify code that employs conditional (predicated) instructions,
          merging <SPAN style="font-style: italic;">if/else</SPAN> blocks of
          code that share the same condition.<BR>
          <BR>
          </LI>

          <LI><SPAN style="font-weight: bold;">Simplify extended integer operations</SPAN> - causes
          the decompiler to simplify integer operations, where a single logical value is split into
          high and low pieces that are acted on in multiple stages. The decompiler tries to identify
          these constructions and replaces the multiple stages with a single operation.<BR>
          <BR>
          </LI>

          <LI><SPAN style="font-weight: bold;">Use in-place assignment operators</SPAN> - causes the
          decompiler to employ in-place C assignment operators such as += in the decompiled
          syntax.<BR>
          </LI>
          
          <LI><SPAN style="font-weight: bold;">Decompiler Timeout (seconds)</SPAN> - the number 
          of seconds to allow the decompiler to run before terminating the decompiler. 
		  
		  Currently this does not affect the UI, which will run indefinitely.
		  This setting currently only affects background analysis that uses the decompiler.
          syntax.<BR>
          </LI>
          
        </UL><BR>
      </BLOCKQUOTE>

      <H3><A name="Data_Mutability"></A>Data Mutability<BR>
      </H3>

      <BLOCKQUOTE>
        <P>Decompiler output can be influenced by the mutability of data locations within
        memory.&nbsp; Supported mutability settings include:<BR>
        </P>

        <UL>
          <LI><SPAN style="font-weight: bold;">Read-only/Constant</SPAN> - indicates that a memory
          locations value never changes and the currently stored value can be treated as a
          constant.<BR>
          </LI>

          <LI><SPAN style="font-weight: bold;">Volatile</SPAN> - indicates that a memory location's
          value may change asynchronously between reads.&nbsp; Reads and writes to such locations
          are never simplified by the decompiler and are wrapped with specially named function
          calls (e.g., volatile_read, volatile_write).&nbsp; The language definition and compiler
          specification may predefine specific volatile regions of memory and may also override the
          default volatile read/write function names.</LI>
        </UL>

        <P>Data mutability may be controlled by the user in one of two ways:<BR>
        </P>

        <OL>
          <LI><A href="help/topics/MemoryMapPlugin/Memory_Map.htm">Memory Block Settings</A></LI>

          <LI><A href="help/topics/DataPlugin/Data.htm#Data_Settings">Data Settings</A><BR>
          </LI>
        </OL>
      </BLOCKQUOTE>
    </BLOCKQUOTE>

    <H2>Tips:</H2>

    <BLOCKQUOTE>
      <BLOCKQUOTE>
        <P><IMG alt="" src="../../shared/note.png" border="0"> It is important to note that the
        decompiler is only as good as the definition of the the underlying assembly language code.
        Each assembly instruction has an associated PCODE definition that describes what the
        instruction does, essentially an RTL (Register Transfer Language). For example, the
        following MOV instruction which moves a value into an offset onto the stack also has a
        PCODE definition.</P>

        <BLOCKQUOTE>
          <P>MOV local_1c[ESP], 0x804aac8</P>

          <BLOCKQUOTE>
            <P><FONT color="#008000">temp1</FONT> = INT_ADD 0x4, ESP<BR>
             <FONT color="#008000">temp2</FONT> = COPY 0x804aac8<BR>
             STORE ram(<FONT color="#008000">temp1</FONT>), <FONT color="#008000">temp2</FONT></P>
          </BLOCKQUOTE>
        </BLOCKQUOTE>

        <P>Irregularities in the produced C-code can often be attributed to errors in this
        underlying definition. Such errors can usually be fixed quickly. <FONT color="red">Please
        feedback any problems or issues you find.</FONT></P>
      </BLOCKQUOTE>
    </BLOCKQUOTE>

    <BLOCKQUOTE>
      <UL>
        <LI>A good way to start using the decompiler is by defining the parameters to functions
        that are obviously "char *" string references. This allows the decompiler to discover and
        display any static strings referenced anywhere the function is called.<BR>
        </LI>

        <LI style="list-style-type: none; list-style-image: none; list-style-position: outside;">
          <UL>
            <LI>The decompiler can work out references to fields of a data structure and figure out
            array indexing given enough information about data types. Building these data type
            definitions greatly enhances readability of the C-code and is a natural way to
            encapsulate reverse engineering knowledge. If you notice many offset references from a
            base value other than the frame or stack pointer, that value is probably pointing to a
            structure or an array. Notice psParm1 in the code below. There are several different
            references off of it. The parameter can be annotated to point to a structure. The user
            can create a new structure or use one from a Ghidra data type library.</LI>
          </UL>

          <BLOCKQUOTE>
            <P>Without knowing the data type, the decompiler produces the following C-code.</P>

            <P><IMG alt="" src="images/Structnotapplied.png" border="0"></P>

            <P>After applying the appropriate structure, the code becomes:</P>

            <P><IMG alt="" src="images/StructApplied.png" border="0"></P>
          </BLOCKQUOTE>

          <UL>
            <LI>
              The parameters shown where a function is called may not agree with the
              parameters where the function is defined. This can be caused by several
              things: 

              <UL>
                <LI>The function takes variable arguments.</LI>

                <LI>The parameters are not actually referenced (used) by the function.</LI>

                <LI>The decompiler does not see the parameter location being filled.</LI>
              </UL>

              <P>Parameters determined from the function definition are more likely to be correct.</P>
            </LI>
          </UL>
        </LI>
      </UL>
    </BLOCKQUOTE>

    <H1><A name="Decompiler_Window"></A>Decompiler Window</H1>

    <P>To display the decompiler window, position the cursor on a function in the Code Browser,
    then select the <IMG alt="" src="images/decompileFunction.gif" border="0"> icon from the tool
    bar, or the <B>Decompile</B> option from the <B>Window</B> menu in the tool.</P>

    <P>Errors from the decompiler process are reported in the status area of the tool and sometimes
    at the end of the C code in the decompiler window.<BR>
    </P>

    <H2>Mouse Actions</H2>

    <BLOCKQUOTE>
      <UL>
        <LI><B>Double-click</B> - Navigates to the symbol that was clicked.</LI>

        <LI><B>Control-double-click</B> - Navigates to the symbol that was clicked, opening the
        results in a new window.</LI>

        <LI><B>Control-shift-click</B> - Triggers the Listing in a <A href=
        "help/topics/Snapshots/Snapshots.html">Snapshots</A> view to navigate to the address
        denoted by the symbol that was clicked.</LI>
        
        <LI><B>Middle-mouse</B> - If you press the middle mouse
      	button  the decompiler will highlight every occurrence of a variable or constant
      	under the current cursor location (the button changed in the tool options under 
      	<B>Browser Field-&gt;Cursor Text Highlight</B>).</LI>        
      </UL>

	   <BLOCKQUOTE>
	      <P><IMG alt="" src="../../shared/tip.png" border="0">You can navigate to the target 
	      of a <code>goto</code> statement by double-clicking its label (you can also double-click 
	      a brace to navigate to the matching brace).<BR>
	      </P>	
      	</BLOCKQUOTE>
    </BLOCKQUOTE>
    <BR>
     <BR>
     

    <P>Other actions available in the decompiler are described in the following paragraphs.<BR>
    </P>

    <H3 style="margin-left: 40px;"><A name="Copy"></A>Copy/Copy Special...<BR>
    </H3>

    <BLOCKQUOTE>
      <P style="margin-left: 40px;">C Code from the decompiler window can be copied and pasted into
      any other system text window. Select the text to copy, and then choose <B>Copy</B> from the
      popup menu.<BR>
      </P>
    </BLOCKQUOTE>

    <H3 style="margin-left: 40px;"><A name="Comments"></A>Comments-&gt;Set...<BR>
    </H3>

    <P style="margin-left: 80px;">Set a comment on a line of C-Code.&nbsp; The comment will be
    stored in the program database at the closest assembly line associated with the generated
    C-Code.&nbsp; Any type of comment (EOL, Post, Pre, Plate) can be attached to the representative
    C-Code.&nbsp; When this function is re-displayed at some later point, the comment will
    persist.<BR>
    </P>

    <H3 style="margin-left: 40px;"><A name="Commit_Params_Return"></A>Commit Params/Return<BR>
    </H3>

    <P style="margin-left: 80px;">By default, the decompiler will analyze the code to try to
    discover function parameters, return type, and local variables. Each time the decompiler
    displays C-code for a function it does this analysis again. <SPAN style=
    "font-weight: bold;">Commit Params/Return</SPAN> causes any parameter names and types and
    return type to be saved in the program database so that next time the function is decompiled
    the current definitions will be used. This is useful for "syncing" the function signature with
    the disassembly display. This causes the names and types of parameters and returns in the
    disassembly to agree with the decompiler names and types.</P>

    <P style="margin-left: 80px;">Ghidra will do stack analysis that will recover parameters and
    return types, but for many programs, the analysis the decompiler does is better.</P>

    <P style="margin-left: 80px;"><IMG alt="" src="../../shared/note.png" border="0">There is a
    prototype plug-in that automatically pulls in the decompiler derived information and applies it
    to each function as the function is created.</P>

    <P style="margin-left: 80px;"><IMG alt="" src="../../shared/note.png" border="0"> If a variable
    displayed in the assembly window has an undefined type, the decompiler will still respect the
    name of the variable.<BR>
    </P>

    <H3 style="margin-left: 40px;"><A name="Commit_Locals"></A>Commit Locals<BR>
    </H3>

    <P style="margin-left: 80px;">By default, the decompiler will analyze the code to try to
    discover function parameters, return type, and local variables. Each time the decompiler
    displays C-code for a function it does this analysis again. <SPAN style=
    "font-weight: bold;">Commit Locals</SPAN> causes any local variable names and types to be saved
    in the program database so that next time the function is decompiled the current local variable
    definitions will be used. This is useful for "syncing" the local variable definitions with the
    disassembly display. This causes the names and types of locals in the disassembly to agree with
    the decompiler names and types.</P>

    <P style="margin-left: 80px;">Ghidra will do stack analysis that will recover local variables
    on the stack, but for many programs, the analysis the decompiler does is better.<BR>
    </P>

    <P style="margin-left: 80px;"><IMG alt="" src="../../shared/note.png" border="0"> There is a
    prototype plug-in that automatically pulls in the decompiler derived information and applies it
    to each function as the function is created.&nbsp; The plugin by default will not commit local
    variable definitions, either stack or register locals.&nbsp; Committing locals automatically
    can be turned on by changing the analysis options for the Decompiler Parameter ID plugin.&nbsp;
    In most cases it is better to commit locals only for certain functions that you really care
    about, or after the data type definitions (structures, etc...) have settled down for the
    program you are Reverse Engineering.<BR>
    </P>

    <P style="margin-left: 80px;"><IMG alt="" src="../../shared/note.png" border="0"> If a variable
    displayed in the assembly window has an undefined type, the decompiler will still respect the
    name of the variable.<BR>
    </P>

    <H3 style="margin-left: 40px;"><A name="Recover_Structure_Variable"></A>Auto Create Structure /
    Auto Fill in Structure<BR>
    </H3>

    <P style="margin-left: 80px;">Automatically creates a structure definition for the pointed to
    structure, and fills it out based on the references found by the decompiler.</P>

    <P style="margin-left: 80px;">To use this, place the cursor on a function parameter variable,
    or any variable within a function that is a pointer to a structure.&nbsp; It could currently
    have a data type of undefined, int, void *, char *, etc...&nbsp; For example:&nbsp; func(int
    *this), (for a C++ this call function).</P>

    <P style="margin-left: 80px;">If the variable is already a structure pointer, any new
    references found will be added to the structure, even if the structure must grow in size.&nbsp;
    This is very useful as you find more places the structure is used.&nbsp; If you have already
    started recovering a portion of a structure and find it used in another function.&nbsp; Retype
    the variable to be the structure, and then use <SPAN style="font-weight: bold;">Auto Fill in
    Structure</SPAN> to add any new fields recovered for the structure.<BR>
    </P>

    <P style="margin-left: 80px;">This feature is also available in the assembly listing when the
    cursor is placed on a defined parameter or return variable.<BR>
    </P>

    <P style="margin-left: 80px;"><IMG alt="" src="../../shared/note.png" border="0">Currently this
    only recovers the structure by following the structure pointer through the current function and
    any function the structure is passed into within the current function.&nbsp; Eventually this
    will be put into a global type analyzer, but for now it is most useful interactively.<BR>
    </P>

    <P style="margin-left: 80px;"><IMG alt="" src="../../shared/note.png" border="0">For best
    results, the function should be well formed with good flow, and all the switch statements
    should be recoverable.</P>

    <P style="margin-left: 80px;"><IMG alt="" src="../../shared/note.png" border="0">There is also
    a script called <SPAN style="font-weight: bold;">CreateStructure</SPAN> that you can use for
    automated structure recovery.&nbsp; For instance if you have a set of ThisCall routines where
    the first parameter to all the routines is a pointer to a shared class structure, the script
    could be modified to recover the structure for each this parameter.</P>

    <BLOCKQUOTE>
      <H3><A name="Highlight_Defined_Use"></A>Highlight Def-Use</H3>

      <BLOCKQUOTE>
        <P>Highlights all places a value is used, starting at the place it is first written, and
        including all the places where that one value is read. This is usually a proper subset of
        all the places a variable appears in the function Place the cursor over a variable you
        would like to highlight and select Highlight Def-Use from the pop-up menu.</P>

        <P>As an example the <I>a</I> at the top of the function is under the cursor when Highlight
        Def-Use is chosen.</P>

        <CENTER>
          <P><IMG alt="" src="images/Defuse.png" border="0"></P>
        </CENTER>

        <P>Notice that the first three references to <I>a</I> are highlighted but the final use of
        <I>a</I> is not because the value might have changed in the <I>else</I> clause.</P>
      </BLOCKQUOTE>

      <H3><A name="Highlight_Forward_Slice"></A>Highlight Forward Slice</H3>

      <BLOCKQUOTE>
        <P>Highlight Forward Slice highlights each variable whose value may be affected by the
        value in the variable under the cursor.</P>

        <P>As an example, <I>b</I>, the output of <I>max_alpha</I>, is under the cursor when
        Highlight Forward Slice is chosen.</P>

        <CENTER>
          <P><IMG alt="" src="images/ForwardSlice.png" border="0"></P>
        </CENTER>

        <P>We can see that <I>c</I> is tainted by the value of <I>b</I> all the way through to the
        bottom of the function.</P>
      </BLOCKQUOTE>

      <H3><A name="Highlight_Backward_Slice"></A>Highlight Backward Slice</H3>

      <BLOCKQUOTE>
        <P>Highlight Backward Slice highlights all points in the function that contain a value
        involved in the creation of the value in the variable under the cursor.</P>

        <P>As an example the final <I>a</I> of the function is under the cursor when Highlight
        Backward Slice is chosen.</P>

        <CENTER>
          <P><IMG alt="" src="images/BackwardSlice.png" border="0"></P>
        </CENTER>

        <P>We can see that the final value of <I>a</I> is affected by the loop and by the input
        parameter but never by <I>b</I> and <I>c</I>.</P>
      </BLOCKQUOTE>

      <H3><A name="Highlight_Forward_Inst_Slice"></A>Highlight Forward Instruction Slice</H3>

      <BLOCKQUOTE>
        <P>Highlight Forward Inst Slice highlights each instruction whose value may be affected by
        the value in the variable under the cursor, rather than the values themselves.</P>
      </BLOCKQUOTE>

      <H3><A name="Highlight_Backward_Inst_Slice"></A>Highlight Backward Instruction Slice</H3>

      <BLOCKQUOTE>
        <P>Highlight Backward Inst Slice highlights all instructions in the function that
        contribute to the creation of the value in the variable under the cursor.</P>
      </BLOCKQUOTE>

      <H3><A name="Rename_Variable"></A>Rename Variable</H3>

      <BLOCKQUOTE>
        <P><FONT color="#000000">Any parameter or local variable can be renamed. Just place the
        cursor over a variable definition, or any use of the variable and choose <B>Rename
        Variable</B> from the popup menu. The name will now be saved for this function, so the next
        time the decompiler displays the code for the function, the same name is used.</FONT></P>
      </BLOCKQUOTE>

      <H3><A name="Rename_Function"></A>Rename Function</H3>

      <BLOCKQUOTE>
        <P>A shortcut for renaming the function from within the decompiler window.</P>
      </BLOCKQUOTE>

      <H3><A name="Retype_Variable"></A>Retype Variable</H3>

      <BLOCKQUOTE>
        <P>The decompiler does its best to recover the type of a variable automatically but often
        only has limited information for analysis. Explicitly changing the type of a variable can
        dramatically improve the C-code produced. This is especially true for structures. Changing
        the type of a parameter variable will affect the display for every place the function is
        called.</P>

        <P>To change a variables data type; place the cursor over the variable definition or use of
        the variable, select <B>Retype Variable</B> from the popup menu, and then enter the name of
        the type. The name of any data type known to the program can be used.</P>

        <P>A simple code improvement is to locate any functions with obvious string parameters and
        re-type the parameter to be a "char *". Any references to defined memory will now display
        the passed parameter as a character "string".</P>
      </BLOCKQUOTE>

      <H3><A name="EditDataType"></A>Edit Data Type of Variable<BR>
      </H3>

      <BLOCKQUOTE>
        <P>Only structure, union, and enum data types can be edited. If a variable's data type is
        one of these it can be edited. Also, if the data type is a type definition, array, or
        pointer based on an editable data type, then the base data type can be edited. For example,
        if you have a structure pointer for a variable then you can edit the structure. To edit a
        variable's data type; place the cursor over the variable definition or use of the variable
        and select <B>Edit Data Type...</B> from the popup menu. For structures and unions, the <A
        href="help/topics/DataTypeEditors/StructureEditor.htm"><FONT color="#0000ff">structure
        editor</FONT></A> will appear, and for enums the <A href=
        "help/topics/DataTypeEditors/EnumEditor.htm">enum editor</A> will appear. If the data type
        for a variable can't be edited, the action will be disabled in the popup.&nbsp;</P>
      </BLOCKQUOTE>

      <H3><A name="Edit_Function_Signature"></A>Edit Function Signature</H3>

      <BLOCKQUOTE>
        <P>The <B>Edit Function Signature</B> dialog allows you to change the function's signature,
        the calling convention, whether the function is inline and whether the function has no
        return.<BR>
        <BR>
        </P>

        <DIV align="center">
          <IMG src="images/EditFunctionSignature.png" alt=""><BR>
        </DIV>

        <P>The function signature includes</P>

        <UL>
          <LI>function name</LI>

          <LI>return type</LI>

          <LI>number of parameters</LI>

          <LI>parameter names</LI>

          <LI>parameter type</LI>

          <LI>varargs (variable arguments)</LI>
        </UL>

        <P>This features allows you to edit a function signature text string to change any of
        these.<BR>
         For example if a function is actually printf(), instead of changing the name, return type,
        and parameters individually, the entire function signature can be changed all at once. To
        do this you could enter<BR>
         &nbsp;&nbsp;&nbsp; <I>void printf( char *fmt, ...)</I><BR>
         within the <B>Signature</B> field and then select the OK button.<BR>
        </P>

        <P>In addition, you can select the <B>Calling Convention</B> for this function from a list
        of available calling conventions as determined by the program's language. Selecting the
        <B>Inline</B> checkbox indicates that the function is in-lined. Selecting the <B>No
        Return</B> checkbox indicates that the function does not return.<BR>
        </P>

        <P><IMG src="../../shared/note.png" alt="">The signature of the current function, or any
        called function can be changed.</P>

        <P>To edit a function's signature from the <B>Decompile</B> window. Just place the cursor
        over any function name, select <B>Edit Function Signature</B> from the popup menu, and the
        dialog will appear with the function's current information.<BR>
        </P>
      </BLOCKQUOTE>

      <H3><A name="Override_Signature"></A>Override Signature</H3>

      <BLOCKQUOTE>
        <P>Overrides the signature of a called function at the point it is called. This allows you
        to set the parameter values for a particular call.</P>
      </BLOCKQUOTE>

      <H3><A name="Remove_Signature_Override"></A>Remove Signature Override</H3>

      <BLOCKQUOTE>
        <P>This action allows you to remove a previously added function signature override.</P>
      </BLOCKQUOTE>

      <H3><A name="Find"></A>Find...</H3>

      <BLOCKQUOTE>
        <P>Find any string of text within the currently decompiled function.<BR>
        </P>
      </BLOCKQUOTE>

      <H3><A name="Debug_Function_Decompilation"></A>Debug Function Decompilation</H3>

      <BLOCKQUOTE>
        <P>For certain functions, the decompiler may produce an error message, produce incorrect
        code, or simply exit without producing results. Selecting <B><IMG alt="\/" src=
        "../../shared/menu16.gif"> Debug Function Decompilation</B>, from the decompiler provider
        window toolbar, will run the decompiler again, and save all relevant information to an XML
        file. Instead of submitting the entire program to be analyzed to discover the problem, only
        a small XML file is needed.<BR>
        </P>
      </BLOCKQUOTE>

      <H3><A name="Graph_AST_Control_Flow"></A>Graph AST Control Flow</H3>

      <BLOCKQUOTE>
        <P>Selecting <B><IMG alt="" src="../../shared/menu16.gif">Graph AST Control Flow</B>,
        from the decompiler provider window toolbar, will generate an abstract syntax tree (AST)
        control flow graph based upon the decompiler results and render the graph within the
        current Graph Service.</P>
        
		      <BLOCKQUOTE>
		      <P><IMG alt="" src="../../shared/note.yellow.png" border="0">If no Graph Service is
		      available then this action will not be present.
		      </P>
		      </BLOCKQUOTE>        
        
      </BLOCKQUOTE>

      <H3><A name="Export_to_C"></A>Export to C <IMG alt="" src="images/page_edit.png" border=
      "0"></H3>

      <BLOCKQUOTE>
        <P>You can export the current decompiled function to a file by selecting the <IMG alt=""
        src="images/page_edit.png" border="0"> icon in the local tool bar of the decompiler window.
        A file chooser dialog is displayed for you to select the name of the output file. If you do
        not specify a file extension, ".c" is appended to the filename.</P>
      </BLOCKQUOTE>

      <H3><A name="Snapshot"></A>Snapshot <IMG alt="" src="images/camera-photo.png" border=
      "0"></H3>

      <BLOCKQUOTE>
        <P>Creates a <A href="help/topics/Snapshots/Snapshots.html">Snapshot</A> of the current
        decompiler window, which allows you to leave the current decompiled function in place while
        navigating to other functions.</P>
      </BLOCKQUOTE>

      <H3><A name="DecompilerProperties"></A>Properties</H3>

      <BLOCKQUOTE>
        <P>The colors used in the decompiler window can be changed by editing the C Display Options
        through the <I>Edit Options</I> dialog. To edit the options, choose <B>Edit</B><IMG alt=""
        src="../../shared/arrow.gif" border="0"> <B>Tool Options...</B> from the tool menu. Click
        on the <I>C Display node</I> in the Options tree. A panel shows the colors that can be
        customized. Click on the color bar to bring up the color chooser to change the color.</P>

        <P>The other options allow you to change the maximum characters in a line displayed in the
        decompiler window, and the number of characters for indenting in the code.</P>
      </BLOCKQUOTE>
    </BLOCKQUOTE>

    <H2>Mouse Hovers</H2>

    <BLOCKQUOTE>
      <P>These function similarly to <A href=
      "help/topics/CodeBrowserPlugin/CodeBrowser.htm#MouseHover">Code Browser Mouse Hovers</A></P>
    </BLOCKQUOTE>

    <P class="providedbyplugin">Provided by: <I>Decompiler Plugin</I></P>

    <P class="relatedtopic">Related Topics:</P>

    <UL>
      <LI><A href="help/topics/CodeBrowserPlugin/CodeBrowser.htm">Code Browser</A></LI>

      <LI><A href="help/topics/Snapshots/Snapshots.html">Snapshots</A></LI>
    </UL>
  </BODY>
</HTML>
