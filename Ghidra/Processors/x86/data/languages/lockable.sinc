# The LOCK prefix is only valid for certain instructions, otherwise, from the
# Intel instruction manual:
#     An undefined opcode exception will also be generated if the LOCK prefix
#     is used with any instruction not in the above list.
# The instructions in this file have their non-lockable counterparts in ia.sinc

:ADC^lockx spec_m8,imm8		is vexMode=0 & lockx & unlock & (byte=0x80 | byte=0x82); spec_m8 & reg_opcode=2 ... ; imm8 
{ 
    build lockx; 
    build spec_m8;
    addCarryFlags( spec_m8, imm8:1 ); 
    resultflags( spec_m8 );
    build unlock;
}

:ADC^lockx spec_m16,imm16	is vexMode=0 & lockx & unlock & opsize=0 & byte=0x81; spec_m16 & reg_opcode=2 ...; imm16 
{    
    build lockx;
    build spec_m16;
    addCarryFlags( spec_m16, imm16:2 );
    resultflags( spec_m16 );
    build unlock; 
}

:ADC^lockx spec_m32,imm32	is vexMode=0 & lockx & unlock & opsize=1 & byte=0x81; spec_m32 & reg_opcode=2 ...; imm32 
{    
    build lockx;
    build spec_m32;
    addCarryFlags( spec_m32, imm32:4 );
    resultflags( spec_m32 );
    build unlock; 
}

@ifdef IA64
:ADC^lockx spec_m64,simm32       is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x81; spec_m64 & reg_opcode=2 ...; simm32 
{    
    build lockx;
    build spec_m64;
    addCarryFlags( spec_m64, simm32 );
    resultflags( spec_m64 );
    build unlock; 
}
@endif

:ADC^lockx spec_m16,simm8_16	is vexMode=0 & lockx & unlock & opsize=0 & byte=0x83; spec_m16 & reg_opcode=2 ...; simm8_16	
{
    build lockx; 
    build spec_m16;
    addCarryFlags( spec_m16, simm8_16 );
    resultflags( spec_m16 );
    build unlock; 
}

:ADC^lockx spec_m32,simm8_32	is vexMode=0 & lockx & unlock & opsize=1 & byte=0x83; spec_m32 & reg_opcode=2 ...; simm8_32 
{
    build lockx;
    build spec_m32;
    addCarryFlags( spec_m32, simm8_32 );
    resultflags( spec_m32 );
    build unlock; 
}

@ifdef IA64
:ADC^lockx spec_m64,simm8_64	is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x83; spec_m64 & reg_opcode=2 ...; simm8_64 
{
    build lockx;
    build spec_m64;
    addCarryFlags( spec_m64, simm8_64 );
    resultflags( spec_m64 );
    build unlock; 
}
@endif

:ADC^lockx m8,Reg8      is vexMode=0 & lockx & unlock & byte=0x10; m8 & Reg8 ...                 
{
    build lockx;
    build m8;
    addCarryFlags( m8, Reg8 );
    resultflags( m8 );
    build unlock;
}

:ADC^lockx m16,Reg16    is vexMode=0 & lockx & unlock & opsize=0 & byte=0x11; m16 & Reg16 ...    
{
    build lockx;
    build m16;
    addCarryFlags( m16, Reg16 );
    resultflags( m16 );
    build unlock;
}

:ADC^lockx m32,Reg32    is vexMode=0 & lockx & unlock & opsize=1 & byte=0x11; m32 & Reg32 ...    
{
    build lockx;
    build m32;
    addCarryFlags( m32, Reg32 );
    resultflags( m32 );
    build unlock;
}

@ifdef IA64
:ADC^lockx m64,Reg64    is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x11; m64 & Reg64 ...    
{
    build lockx;
    build m64;
    addCarryFlags( m64, Reg64 );
    resultflags( m64 );
    build unlock;
}
@endif

define pcodeop InterlockedAdd;
:ADD^lockx spec_m8,imm8		is vexMode=0 & lockx & unlock & (byte=0x80 | byte=0x82); spec_m8 & reg_opcode=0 ...; imm8		
{
    build lockx;
    build spec_m8;
    addflags( spec_m8,imm8 );
    spec_m8 =   spec_m8 +  imm8;
    resultflags(  spec_m8);
    build unlock;
}

:ADD^lockx spec_m16,imm16		is vexMode=0 & lockx & unlock & opsize=0 & byte=0x81; spec_m16 & reg_opcode=0 ...; imm16	
{
    build lockx;
    build spec_m16;
    addflags( spec_m16,imm16);
    spec_m16 =  spec_m16 + imm16;
    resultflags( spec_m16);
    build unlock;
}

:ADD^lockx spec_m32,imm32		is vexMode=0 & lockx & unlock & opsize=1 & byte=0x81; spec_m32 & reg_opcode=0 ...; imm32	
{
    build lockx;
    build spec_m32;
    addflags( spec_m32,imm32);
    spec_m32 =  spec_m32 + imm32;
    resultflags( spec_m32);
    build unlock;
}

@ifdef IA64
define pcodeop InterlockedAdd64;
:ADD^lockx spec_m64,simm32		is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x81; spec_m64 & reg_opcode=0 ...; simm32	
{
    build lockx;
    build spec_m64;
    addflags( spec_m64,simm32);
    spec_m64 =  spec_m64 + simm32;
    resultflags( spec_m64);
    build unlock;
}
@endif

:ADD^lockx spec_m16,simm8_16		is vexMode=0 & lockx & unlock & opsize=0 & byte=0x83; spec_m16 & reg_opcode=0 ...; simm8_16	
{
    build lockx;
    build spec_m16;
    addflags( spec_m16,simm8_16);
    spec_m16 =  spec_m16 + simm8_16;
    resultflags( spec_m16);
    build unlock;
}

:ADD^lockx spec_m32,simm8_32		is vexMode=0 & lockx & unlock & opsize=1 & byte=0x83; spec_m32 & reg_opcode=0 ...; simm8_32	
{
    build lockx;
    build spec_m32;
    addflags( spec_m32,simm8_32);
    spec_m32 =  spec_m32 + simm8_32;
    resultflags( spec_m32);
    build unlock;
}

@ifdef IA64
:ADD^lockx spec_m64,simm8_64		is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x83; spec_m64 & reg_opcode=0 ...; simm8_64	
{
    build lockx;
    build spec_m64;
    addflags( spec_m64,simm8_64);
    spec_m64 =  spec_m64 + simm8_64;
    resultflags( spec_m64);
    build unlock;
}
@endif



:ADD^lockx_ Mem,Reg8    is vexMode=0 & lockx_ & lockprefx & byte=0x00; Mem & Reg8 ...
{
    tmp:1 = lockprefx;
    if (tmp == 1) goto <interlocked>;
    *:1 Mem = *:1 Mem + Reg8;
    goto <end>;
<interlocked>
    *:1 Mem = InterlockedAdd(Mem, Reg8);
<end>
}

:ADD^lockx_ Mem,Reg16   is vexMode=0 & lockx_ & lockprefx & opsize=0 & byte=0x1; Mem & Reg16 ...
{
    tmp:1 = lockprefx;
    if (tmp == 1) goto <interlocked>;
    *:2 Mem = *:2 Mem + Reg16;
    goto <end>;
<interlocked>
    *:2 Mem = InterlockedAdd(Mem, Reg16);
<end>
}

:ADD^lockx_ Mem,Reg32   is vexMode=0 & lockx_ & lockprefx & opsize=1 & byte=0x1; Mem & Reg32 ...
{
    tmp:1 = lockprefx;
    if (tmp == 1) goto <interlocked>;
    *:4 Mem = *:4 Mem + Reg32;
    goto <end>;
<interlocked>
    *:4 Mem = InterlockedAdd(Mem, Reg32);
<end>
}

@ifdef IA64
:ADD^lockx_ Mem,Reg64   is $(LONGMODE_ON) & vexMode=0 & lockx_ & lockprefx & opsize=2 & byte=0x1; Mem & Reg64 ...
{
    tmp:1 = lockprefx;
    if (tmp == 1) goto <interlocked>;
    *:8 Mem = *:8 Mem + Reg64;
    goto <end>;
<interlocked>
    *:8 Mem = InterlockedAdd(Mem, Reg64);
<end>
}
@endif

:AND^lockx m8,imm8      is vexMode=0 & lockx & unlock & (byte=0x80 | byte=0x82); m8 & reg_opcode=4 ...; imm8     
{
    build lockx;
    build m8;
    logicalflags();
    m8 =   m8 &  imm8;
    resultflags(  m8);
    build unlock;
}

:AND^lockx m16,imm16    is vexMode=0 & lockx & unlock & opsize=0 & byte=0x81; m16 & reg_opcode=4 ...; imm16  
{
    build lockx;
    build m16;
    logicalflags();
    m16 =  m16 & imm16;
    resultflags( m16);
    build unlock;
}

:AND^lockx m32,imm32    is vexMode=0 & lockx & unlock & opsize=1 & byte=0x81; m32 & reg_opcode=4 ...; imm32  
{
    build lockx;
    build m32;
    logicalflags();
    m32 =  m32 & imm32;
    resultflags( m32);
    build unlock;
}

@ifdef IA64
:AND^lockx m64,simm32    is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x81; m64 & reg_opcode=4 ...; simm32  
{
    build lockx;
    build m64;
    logicalflags();
    m64 =  m64 & simm32;
    resultflags( m64);
    build unlock;
}
@endif

:AND^lockx m16,usimm8_16		is vexMode=0 & lockx & unlock & opsize=0 & byte=0x83; m16 & reg_opcode=4 ...; usimm8_16	
{
    build lockx;
    build m16;
    logicalflags();
    m16 =  m16 & usimm8_16;
    resultflags( m16);
    build unlock;
}

:AND^lockx m32,usimm8_32		is vexMode=0 & lockx & unlock & opsize=1 & byte=0x83; m32 & reg_opcode=4 ...; usimm8_32	
{
    build lockx;
    build m32;
    logicalflags();
    m32 =  m32 & usimm8_32;
    resultflags( m32);
    build unlock; 
}

@ifdef IA64
:AND^lockx m64,usimm8_64		is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x83; m64 & reg_opcode=4 ...; usimm8_64	
{
    build lockx;
    build m64;
    logicalflags();
    m64 =  m64 & usimm8_64;
    resultflags( m64);
    build unlock; 
}
@endif

:AND^lockx m8,Reg8      is vexMode=0 & lockx & unlock & byte=0x20; m8 & Reg8 ...                     
{
    build lockx;
    build m8;
    logicalflags();
    m8 =   m8 &  Reg8;
    resultflags(  m8);
    build unlock; 
}

:AND^lockx m16,Reg16    is vexMode=0 & lockx & unlock & opsize=0 & byte=0x21; m16 & Reg16 ...        
{
    build lockx;
    build m16;
    logicalflags();
    m16 =  m16 & Reg16;
    resultflags( m16);
    build unlock; 
}

:AND^lockx m32,Reg32    is vexMode=0 & lockx & unlock & opsize=1 & byte=0x21; m32 & Reg32 ...        
{
    build lockx;
    build m32;
    logicalflags();
    m32 =  m32 & Reg32;
    resultflags( m32);
    build unlock; 
}

@ifdef IA64
:AND^lockx m64,Reg64    is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x21; m64 & Reg64 ...        
{
    build lockx;
    build m64;
    logicalflags();
    m64 =  m64 & Reg64;
    resultflags( m64);
    build unlock; 
}
@endif

:BTC^lockx Mem,Reg16	is vexMode=0 & lockx & unlock & opsize=0 & byte=0xf; byte=0xbb; Mem & Reg16 ...		
{
    build lockx;
    build Mem;
    local ptr = Mem + (sext(Reg16) s>> 3);
    local bit=Reg16&7;
    local val = (*:1 ptr >> bit) & 1;
    *:1 ptr= *:1 ptr ^(1<<bit);
    CF=(val!=0);
    build unlock; 
}

:BTC^lockx Mem,Reg32	is vexMode=0 & lockx & unlock & opsize=1 & byte=0xf; byte=0xbb; Mem & Reg32 ...		
{
    build lockx;
    build Mem;
@ifdef IA64
    local ptr = Mem + (sext(Reg32) s>> 3);
@else
    local ptr = Mem + (Reg32 s>> 3);
@endif
    local bit=Reg32&7;
    local val = (*:1 ptr >> bit) & 1;
    *:1 ptr = *:1 ptr ^ (1<<bit);
    CF = (val != 0);
    build unlock;
}

@ifdef IA64
:BTC^lockx Mem,Reg64     is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0xf; byte=0xbb; Mem & Reg64 ...		
{
    build lockx;
    build Mem;
    local ptr = Mem + (Reg64 s>> 3);
    local bit=Reg64&7;
    local val = (*:1 ptr >> bit) & 1;
    *:1 ptr = *:1 ptr ^ (1<<bit);
    CF = (val != 0);
    build unlock; 
}
@endif

:BTC^lockx m16,imm8     is vexMode=0 & lockx & unlock & opsize=0 & byte=0xf; byte=0xba; m16 & reg_opcode=7 ...; imm8   
{
    build lockx;
    build m16;
    local bit=imm8&0xf;
    local val=(m16>>bit)&1;
    m16=m16^(1<<bit);
    CF=(val!=0);
    build unlock; 
}

:BTC^lockx m32,imm8     is vexMode=0 & lockx & unlock & opsize=1 & byte=0xf; byte=0xba; m32 & reg_opcode=7 ...; imm8   
{
    build lockx;
    build m32;
    local bit=imm8&0x1f;
    local val=(m32>>bit)&1;
    CF=(val!=0);
    m32=m32^(1<<bit);
    build unlock; 
}

@ifdef IA64
:BTC^lockx m64,imm8     is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0xf; byte=0xba; m64 & reg_opcode=7 ...; imm8   
{
    build lockx;
    build m64;
    local bit=imm8&0x3f;
    local val=(m64>>bit)&1;
    m64=m64^(1<<bit);
    CF=(val!=0);
    build unlock; 
}
@endif

:BTR^lockx Mem,Reg16	is vexMode=0 & lockx & unlock & opsize=0 & byte=0xf; byte=0xb3; Mem & Reg16 ...		
{
    build lockx;
    build Mem;
    local ptr = Mem + (sext(Reg16) s>> 3);
    local bit=Reg16&7;
    local val=(*:1 ptr >> bit) & 1;
    *:1 ptr = *:1 ptr & ~(1<<bit);
    CF = (val!=0);
    build unlock; 
}

:BTR^lockx Mem,Reg32	is vexMode=0 & lockx & unlock & opsize=1 & byte=0xf; byte=0xb3; Mem & Reg32 ...		
{
    build lockx;
    build Mem;
@ifdef IA64
    local ptr = Mem + (sext(Reg32) s>> 3);
@else
    local ptr = Mem + (Reg32 s>> 3);
@endif
    local bit = Reg32 & 7;
    local val = (*:1 ptr >> bit) & 1;
    *:1 ptr = *:1 ptr & ~(1<<bit);
    CF = (val!=0);
    build unlock;
}

@ifdef IA64
:BTR^lockx Mem,Reg64	is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0xf; byte=0xb3; Mem & Reg64 ...		
{
    build lockx;
    build Mem;
    local ptr = Mem + (Reg64 s>> 3);
    local bit = Reg64 & 7;
    local val = (*:1 ptr >> bit) & 1;
    *:1 ptr = *:1 ptr & ~(1<<bit);
    CF = (val!=0);
    build unlock; 
}
@endif

:BTR^lockx m16,imm8     is vexMode=0 & lockx & unlock & opsize=0 & byte=0xf; byte=0xba; m16 & reg_opcode=6 ...; imm8   
{
    build lockx;
    build m16;
    local bit=imm8&0xf;
    local val=(m16>>bit)&1;
    m16=m16 & ~(1<<bit);
    CF=(val!=0);
    build unlock; 
}

:BTR^lockx m32,imm8     is vexMode=0 & lockx & unlock & opsize=1 & byte=0xf; byte=0xba; m32 & reg_opcode=6 ...; imm8   
{
    build lockx;
    build m32;
    local bit=imm8&0x1f;
    local val=(m32>>bit)&1;
    CF=(val!=0);
    m32=m32 & ~(1<<bit);
    build unlock; 
}

@ifdef IA64
:BTR^lockx m64,imm8     is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0xf; byte=0xba; m64 & reg_opcode=6 ...; imm8   
{
    build lockx;
    build m64;
    local bit=imm8&0x3f;
    local val=(m64>>bit)&1;
    m64=m64 & ~(1<<bit);
    CF=(val!=0);
    build unlock; 
}
@endif

:BTS^lockx Mem,Reg16	is vexMode=0 & lockx & unlock & opsize=0 & byte=0xf; byte=0xab; Mem & Reg16 ...		
{
    build lockx;
    build Mem;
    local ptr = Mem + (sext(Reg16) s>> 3);
    local bit = Reg16&7;
    local val = (*:1 ptr >> bit) & 1;
    *:1 ptr = *:1 ptr | (1<<bit);
    CF = (val != 0);
    build unlock; 
}

:BTS^lockx Mem,Reg32	is vexMode=0 & lockx & unlock & opsize=1 & byte=0xf; byte=0xab; Mem & Reg32 ...		
{
    build lockx;
    build Mem;
@ifdef IA64
    local ptr = Mem + (sext(Reg32) s>>3);
@else
    local ptr = Mem + (Reg32 s>>3);
@endif
    local bit = Reg32 & 7;
    local val = (*:1 ptr >> bit) & 1;
    *:1 ptr = *:1 ptr | (1<<bit);
    CF = (val != 0);
    build unlock;
}

@ifdef IA64
:BTS^lockx Mem,Reg64	is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0xf; byte=0xab; Mem & Reg64 ...		
{
    build lockx;
    build Mem;
    local ptr = Mem + (Reg64 s>>3);
    local bit = Reg64 & 7;
    local val = (*:1 ptr >> bit) & 1;
    *:1 ptr = *:1 ptr | (1<<bit);
    CF = (val != 0);
    build unlock; 
}
@endif

:BTS^lockx m16,imm8     is vexMode=0 & lockx & unlock & opsize=0 & byte=0xf; byte=0xba; m16 & reg_opcode=5 ...; imm8   
{
    build lockx;
    build m16;
    local bit=imm8&0xf;
    local val=(m16>>bit)&1;
    m16=m16 | (1<<bit);
    CF=(val!=0);
    build unlock; 
}

:BTS^lockx m32,imm8     is vexMode=0 & lockx & unlock & opsize=1 & byte=0xf; byte=0xba; m32 & reg_opcode=5 ...; imm8   
{
    build lockx;
    build m32;
    local bit=imm8&0x1f;
    local val=(m32>>bit)&1;
    CF=(val!=0);
    m32=m32 | (1<<bit);
    build unlock; 
}

@ifdef IA64
:BTS^lockx m64,imm8     is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0xf; byte=0xba; m64 & reg_opcode=5 ...; imm8   
{
    build lockx;
    build m64;
    local bit=imm8&0x3f;
    local val=(m64>>bit)&1;
    m64=m64 | (1<<bit);
    CF=(val!=0);
    build unlock; 
}
@endif

define pcodeop InterlockedCompareExchange;
define pcodeop InterlockedCompareExchange8;
define pcodeop InterlockedCompareExchange16;
:CMPXCHG^lockx_ Mem,Reg8    is vexMode=0 & lockx_ & byte=0xf; byte=0xb0; Mem & Reg8 ...
{
    AL = InterlockedCompareExchange8(Mem, Reg8, AL);
}

:CMPXCHG^lockx_ Mem,Reg16   is vexMode=0 & lockx_ & opsize=0 & byte=0xf; byte=0xb1; Mem & Reg16 ...
{
    AX = InterlockedCompareExchange16(Mem, Reg16, AX);
}

:CMPXCHG^lockx_ Mem,Reg32   is vexMode=0 & lockx_ & opsize=1 & byte=0xf; byte=0xb1; Mem & Reg32 ...
{
    EAX = InterlockedCompareExchange(Mem, Reg32, EAX);
}

@ifdef IA64
define pcodeop InterlockedCompareExchange64;
:CMPXCHG^lockx_ Mem,Reg64   is $(LONGMODE_ON) & vexMode=0 & lockx_ & opsize=2 & byte=0xf; byte=0xb1; Mem & Reg64 ...
{
    RAX = InterlockedCompareExchange64(Mem, Reg64, RAX);
}
@endif

:CMPXCHG8B^lockx  m64        is vexMode=0 & lockx & unlock & byte=0xf; byte=0xc7; ( mod != 0b11 & reg_opcode=1 ) ... & m64
{
    build lockx;
    local dest = m64;
    ZF = ((zext(EDX) << 32) | zext(EAX)) == dest;
    if (ZF == 1) goto <equal>;
    EDX = dest(4);
    EAX = dest:4;
    goto <done>;
<equal>
    m64 = (zext(ECX) << 32) | zext(EBX);
  <done>
    build unlock;
}

@ifdef IA64
:CMPXCHG16B^lockx  m128	is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0xf; byte=0xc7; ( mod != 0b11 & reg_opcode=1 ) ... & ( m128 ) {
    build lockx;
    local dest = m128;
    ZF = ((zext(RDX) << 64) | zext(RAX)) == dest;
    if (ZF == 1) goto <equal>;
    RDX = dest(8);
    RAX = dest:8;
    goto <done>;
<equal>
    m128 = ((zext(RCX) << 64) | zext(RBX));
<done>
    build unlock;
}
@endif

define pcodeop InterlockedDecrement;
define pcodeop InterlockedDecrement16;
:DEC^lockx_ Mem	is vexMode=0 & lockx_ & lockprefx & byte=0xfe; Mem & reg_opcode=1 ...
{
    tmp:1 = lockprefx;
    if (tmp == 1) goto <interlocked>;
    *:1 Mem = *:1 Mem - 1;
    goto <end>;
<interlocked>
    InterlockedDecrement(Mem);
<end>
}

:DEC^lockx_ Mem	is vexMode=0 & lockx_ & lockprefx & opsize=0 & byte=0xff; Mem & reg_opcode=1 ...
{
    tmp:1 = lockprefx;
    if (tmp == 1) goto <interlocked>;
    *:2 Mem = *:2 Mem - 1;
    goto <end>;
<interlocked>
    InterlockedDecrement16(Mem);
<end>
}

:DEC^lockx_ Mem	is vexMode=0 & lockx_ & lockprefx & opsize=1 & byte=0xff; Mem & reg_opcode=1 ...
{
    tmp:1 = lockprefx;
    if (tmp == 1) goto <interlocked>;
    *:4 Mem = *:4 Mem - 1;
    goto <end>;
<interlocked>
    InterlockedDecrement(Mem);
<end>
}

@ifdef IA64
define pcodeop InterlockedDecrement64;
:DEC^lockx_ Mem	is $(LONGMODE_ON) & vexMode=0 & lockx_ & lockprefx & opsize=2 & byte=0xff; Mem & reg_opcode=1 ...
{
    tmp:1 = lockprefx;
    if (tmp == 1) goto <interlocked>;
    *:8 Mem = *:8 Mem - 1;
    goto <end>;
<interlocked>
    InterlockedDecrement64(Mem);
<end>
}
@endif

define pcodeop InterlockedIncrement;
define pcodeop InterlockedIncrement16;
:INC^lockx_ Mem	is vexMode=0 & lockx_ & lockprefx & byte=0xfe; Mem ...
{
    tmp:1 = lockprefx;
    if (tmp == 1) goto <interlocked>;
    *:1 Mem = *:1 Mem + 1;
    goto <end>;
<interlocked>
    InterlockedIncrement(Mem);
<end>
}

:INC^lockx_ Mem	is vexMode=0 & lockx_ & lockprefx & opsize=0 & byte=0xff; Mem ...
{
    tmp:1 = lockprefx;
    if (tmp == 1) goto <interlocked>;
    *:2 Mem = *:2 Mem + 1;
    goto <end>;
<interlocked>
    InterlockedIncrement16(Mem);
<end>
}

:INC^lockx_ Mem	is vexMode=0 & lockx_ & lockprefx & opsize=1 & byte=0xff; Mem ...
{
    tmp:1 = lockprefx;
    if (tmp == 1) goto <interlocked>;
    *:4 Mem = *:4 Mem - 1;
    goto <end>;
<interlocked>
    InterlockedIncrement(Mem);
<end>
}

@ifdef IA64
define pcodeop InterlockedIncrement64;
:INC^lockx_ Mem	is $(LONGMODE_ON) & vexMode=0 & lockx_ & lockprefx & opsize=2 & byte=0xff; Mem ...
{
    tmp:1 = lockprefx;
    if (tmp == 1) goto <interlocked>;
    *:8 Mem = *:8 Mem + 1;
    goto <end>;
<interlocked>
    InterlockedIncrement64(Mem);
<end>
}
@endif

:NEG^lockx m8       is vexMode=0 & lockx & unlock & byte=0xf6; m8 & reg_opcode=3 ...         
{
    build lockx;
    build m8;
    negflags(m8);
    m8 =  -m8;
    resultflags(m8 );
    build unlock; 
}

:NEG^lockx m16      is vexMode=0 & lockx & unlock & opsize=0 & byte=0xf7; m16 & reg_opcode=3 ... 
{
    build lockx;
    build m16;
    negflags(m16);
    m16 = -m16;
    resultflags(m16);
    build unlock; 
}

:NEG^lockx m32      is vexMode=0 & lockx & unlock & opsize=1 & byte=0xf7; m32 & reg_opcode=3 ... 
{
    build lockx;
    build m32;
    negflags(m32);
    m32 = -m32;
    resultflags(m32);
    build unlock; 
}

@ifdef IA64
:NEG^lockx m64      is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0xf7; m64 & reg_opcode=3 ... 
{
    build lockx;
    build m64;
    negflags(m64);
    m64 = -m64;
    resultflags(m64);
    build unlock; 
}
@endif

:NOT^lockx m8       is vexMode=0 & lockx & unlock & byte=0xf6; m8 & reg_opcode=2 ...         
{
    build lockx;
    build m8;
    m8 =  ~m8;
    build unlock; 
}

:NOT^lockx m16      is vexMode=0 & lockx & unlock & opsize=0 & byte=0xf7; m16 & reg_opcode=2 ... 
{
    build lockx;
    build m16;
    m16 = ~m16;
    build unlock; 
}

:NOT^lockx m32      is vexMode=0 & lockx & unlock & opsize=1 & byte=0xf7; m32 & reg_opcode=2 ... 
{
    build lockx;
    build m32;
    m32 = ~m32;
    build unlock; 
}

@ifdef IA64
:NOT^lockx m64      is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0xf7; m64 & reg_opcode=2 ... 
{
    build lockx;
    build m64;
    m64 = ~m64;
    build unlock; 
}
@endif

:OR^lockx  spec_m8,imm8      is vexMode=0 & lockx & unlock & (byte=0x80 | byte=0x82); spec_m8 & reg_opcode=1 ...; imm8     
{
    build lockx;
    build spec_m8;
    logicalflags();
    spec_m8 =   spec_m8 |  imm8;
    resultflags(  spec_m8);
    build unlock; 
}

:OR^lockx  spec_m16,imm16        is vexMode=0 & lockx & unlock & opsize=0 & byte=0x81; spec_m16 & reg_opcode=1 ...; imm16  
{
    build lockx;
    build spec_m16;
    logicalflags();
    spec_m16 =  spec_m16 | imm16;
    resultflags( spec_m16);
    build unlock; 
}

:OR^lockx  spec_m32,imm32        is vexMode=0 & lockx & unlock & opsize=1 & byte=0x81; spec_m32 & reg_opcode=1 ...; imm32  
{
    build lockx;
    build spec_m32;
    logicalflags();
    spec_m32 =  spec_m32 | imm32;
    resultflags( spec_m32);
    build unlock; 
}

@ifdef IA64
:OR^lockx  spec_m64,simm32       is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x81; spec_m64 & reg_opcode=1 ...; simm32 
{
    build lockx;
    build spec_m64;
    logicalflags();
    tmp:8 = spec_m64;
    spec_m64 =  tmp | simm32;
    resultflags( spec_m64);
    build unlock; 
}
@endif

:OR^lockx  spec_m16,usimm8_16        is vexMode=0 & lockx & unlock & opsize=0 & byte=0x83; spec_m16 & reg_opcode=1 ...; usimm8_16  
{
    build lockx;
    build spec_m16;
    logicalflags();
    spec_m16 =  spec_m16 | usimm8_16;
    resultflags( spec_m16);
    build unlock; 
}

:OR^lockx  spec_m32,usimm8_32        is vexMode=0 & lockx & unlock & opsize=1 & byte=0x83; spec_m32 & reg_opcode=1 ...; usimm8_32  
{
    build lockx;
    build spec_m32;
    logicalflags();
    spec_m32 =  spec_m32 | usimm8_32;
    resultflags( spec_m32);
    build unlock; 
}

@ifdef IA64
:OR^lockx  spec_m64,usimm8_64        is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x83; spec_m64 & reg_opcode=1 ...; usimm8_64  
{
    build lockx;
    build spec_m64;
    logicalflags();
    spec_m64 =  spec_m64 | usimm8_64;
    resultflags( spec_m64);
    build unlock; 
}
@endif

:OR^lockx  m8,Reg8      is vexMode=0 & lockx & unlock & byte=0x8; m8 & Reg8 ...                  
{
    build lockx;
    build m8;
    logicalflags();
    m8 =   m8 |  Reg8;
    resultflags(  m8);
    build unlock; 
}

:OR^lockx  m16,Reg16        is vexMode=0 & lockx & unlock & opsize=0 & byte=0x9; m16 & Reg16 ...     
{
    build lockx;
    build m16;
    logicalflags();
    m16 =  m16 | Reg16;
    resultflags( m16);
    build unlock; 
}

:OR^lockx  m32,Reg32        is vexMode=0 & lockx & unlock & opsize=1 & byte=0x9; m32 & Reg32 ...     
{
    build lockx;
    build m32;
    logicalflags();
    m32 =  m32 | Reg32;
    resultflags( m32);
    build unlock; 
}

@ifdef IA64
:OR^lockx  m64,Reg64        is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x9; m64 & Reg64 ...     
{
    build lockx;
    build m64;
    logicalflags();
    m64 =  m64 | Reg64;
    resultflags( m64);
    build unlock; 
}
@endif

:SBB^lockx  m8,imm8     is vexMode=0 & lockx & unlock & (byte=0x80 | byte=0x82); m8 & reg_opcode=3 ...; imm8								
{
    build lockx;
    build m8;
    subCarryFlags( m8, imm8 );
    resultflags(m8);
    build unlock; 
}

:SBB^lockx  m16,imm16       is vexMode=0 & lockx & unlock & opsize=0 & byte=0x81; m16 & reg_opcode=3 ...; imm16							
{
    build lockx;
    build m16;
    subCarryFlags( m16, imm16 );
    resultflags(m16);
    build unlock; 
}

:SBB^lockx  m32,imm32       is vexMode=0 & lockx & unlock & opsize=1 & byte=0x81; m32 & reg_opcode=3 ...; imm32	
{
    build lockx;
    build m32;
    subCarryFlags( m32, imm32 );
    resultflags(m32);
    build unlock; 
}

@ifdef IA64
:SBB^lockx  m64,imm32       is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x81; m64 & reg_opcode=3 ...; imm32							
{
    build lockx;
    build m64;
    subCarryFlags( m64, imm32 );
    resultflags(m64);
    build unlock; 
}
@endif

:SBB^lockx  m16,simm8_16       is vexMode=0 & lockx & unlock & opsize=0 & byte=0x83; m16 & reg_opcode=3 ...; simm8_16						
{
    build lockx;
    build m16;
    subCarryFlags( m16, simm8_16 );
    resultflags(m16);
    build unlock; 
}

:SBB^lockx  m32,simm8_32       is vexMode=0 & lockx & unlock & opsize=1 & byte=0x83; m32 & reg_opcode=3 ...; simm8_32	
{
    build lockx;
    build m32;
    subCarryFlags( m32, simm8_32 );
    resultflags(m32);
    build unlock; 
}

@ifdef IA64
:SBB^lockx  m64,simm8_64       is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x83; m64 & reg_opcode=3 ...; simm8_64						
{
    build lockx;
    build m64;
    subCarryFlags( m64, simm8_64 );
    resultflags(m64);
    build unlock; 
}
@endif

:SBB^lockx  m8,Reg8     is vexMode=0 & lockx & unlock & byte=0x18; m8 & Reg8 ...											
{
    build lockx;
    build m8;
    subCarryFlags(  m8, Reg8 );
    resultflags(m8);
    build unlock; 
}

:SBB^lockx  m16,Reg16       is vexMode=0 & lockx & unlock & opsize=0 & byte=0x19; m16 & Reg16 ...						
{
    build lockx;
    build m16;
    subCarryFlags( m16, Reg16 );
    resultflags(m16);
    build unlock; 
}

:SBB^lockx  m32,Reg32       is vexMode=0 & lockx & unlock & opsize=1 & byte=0x19; m32 & Reg32 ...	
{
    build lockx;
    build m32;
    subCarryFlags( m32, Reg32 );
    resultflags(m32);
    build unlock; 
}

@ifdef IA64
:SBB^lockx  m64,Reg64       is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x19; m64 & Reg64 ...						
{
    build lockx;
    build m64;
    subCarryFlags( m64, Reg64 );
    resultflags(m64);
    build unlock; 
}
@endif

:SUB^lockx  spec_m8,imm8     is vexMode=0 & lockx & unlock & (byte=0x80 | byte=0x82); spec_m8 & reg_opcode=5 ...; imm8     
{
    build lockx;
    build spec_m8;
    subflags(  spec_m8,imm8 );
    spec_m8 =   spec_m8 -  imm8;
    resultflags(  spec_m8);
    build unlock; 
}

:SUB^lockx  spec_m16,imm16       is vexMode=0 & lockx & unlock & opsize=0 & byte=0x81; spec_m16 & reg_opcode=5 ...; imm16  
{
    build lockx;
    build spec_m16;
    subflags( spec_m16,imm16);
    spec_m16 =  spec_m16 - imm16;
    resultflags( spec_m16);
    build unlock; 
}

:SUB^lockx  spec_m32,imm32       is vexMode=0 & lockx & unlock & opsize=1 & byte=0x81; spec_m32 & reg_opcode=5 ...; imm32  
{
    build lockx;
    build spec_m32;
    subflags( spec_m32,imm32);
    spec_m32 =  spec_m32 - imm32;
    resultflags( spec_m32);
    build unlock; 
}

@ifdef IA64
:SUB^lockx  spec_m64,simm32       is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x81; spec_m64 & reg_opcode=5 ...; simm32  
{
    build lockx;
    build spec_m64;
    subflags( spec_m64,simm32);
    spec_m64 =  spec_m64 - simm32;
    resultflags( spec_m64);
    build unlock; 
}
@endif

:SUB^lockx  spec_m16,simm8_16       is vexMode=0 & lockx & unlock & opsize=0 & byte=0x83; spec_m16 & reg_opcode=5 ...; simm8_16  
{
    build lockx;
    build spec_m16;
    subflags( spec_m16,simm8_16);
    spec_m16 =  spec_m16 - simm8_16;
    resultflags( spec_m16);
    build unlock; 
}

:SUB^lockx  spec_m32,simm8_32       is vexMode=0 & lockx & unlock & opsize=1 & byte=0x83; spec_m32 & reg_opcode=5 ...; simm8_32  
{
    build lockx;
    build spec_m32;
    subflags( spec_m32,simm8_32);
    spec_m32 =  spec_m32 - simm8_32;
    resultflags( spec_m32);
    build unlock; 
}

@ifdef IA64
:SUB^lockx  spec_m64,simm8_64       is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x83; spec_m64 & reg_opcode=5 ...; simm8_64  
{
    build lockx;
    build spec_m64;
    subflags( spec_m64,simm8_64);
    spec_m64 =  spec_m64 - simm8_64;
    resultflags( spec_m64);
    build unlock; 
}
@endif

:SUB^lockx  m8,Reg8     is vexMode=0 & lockx & unlock & byte=0x28; m8 & Reg8 ...                 
{
    build lockx;
    build m8;
    subflags(  m8,Reg8 );
    m8 =   m8 -  Reg8;
    resultflags(  m8);
    build unlock; 
}

:SUB^lockx  m16,Reg16       is vexMode=0 & lockx & unlock & opsize=0 & byte=0x29; m16 & Reg16 ...        
{
    build lockx;
    build m16;
    subflags( m16,Reg16);
    m16 =  m16 - Reg16;
    resultflags( m16);
    build unlock; 
}

:SUB^lockx  m32,Reg32       is vexMode=0 & lockx & unlock & opsize=1 & byte=0x29; m32 & Reg32 ...        
{
    build lockx;
    build m32;
    subflags( m32,Reg32);
    m32 =  m32 - Reg32;
    resultflags( m32);
    build unlock; 
}

@ifdef IA64
:SUB^lockx  m64,Reg64       is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x29; m64 & Reg64 ...        
{
    build lockx;
    build m64;
    subflags( m64,Reg64);
    m64 =  m64 - Reg64;
    resultflags( m64);
    build unlock; 
}
@endif

define pcodeop InterlockedExchangeAdd;
:XADD^lockx_ Mem,Reg8	is vexMode=0 & lockx_ & byte=0x0F; byte=0xC0;  Mem & Reg8  ...
{
    Reg8 = InterlockedExchangeAdd(Mem, Reg8);
}

:XADD^lockx_ Mem,Reg16	is vexMode=0 & lockx_ & opsize=0 & byte=0x0F; byte=0xC1; Mem & Reg16 ...
{
    Reg16 = InterlockedExchangeAdd(Mem, Reg16);
}

:XADD^lockx_ Mem,Reg32	is vexMode=0 & lockx_ & opsize=1 & byte=0x0F; byte=0xC1; Mem & Reg32 ...
{
    Reg32 = InterlockedExchangeAdd(Mem, Reg32);
}

@ifdef IA64
define pcodeop InterlockedExchangeAdd64;
:XADD^lockx_ Mem,Reg64	is $(LONGMODE_ON) & vexMode=0 & lockx_ & opsize=2 & byte=0x0F; byte=0xC1; Mem & Reg64 ...
{
    Reg64 = InterlockedExchangeAdd64(Mem, Reg64);
}
@endif

define pcodeop InterlockedExchange;
define pcodeop InterlockedExchange8;
define pcodeop InterlockedExchange16;
# XCHG with memory operands always asserts a lock signal regardless of prefix presence
:XCHG^xacq_xrel_prefx^alwaysLock Mem,Reg8	is vexMode=0 & xacq_xrel_prefx & alwaysLock & byte=0x86; Mem & Reg8 ...
{
    Reg8 = InterlockedExchange8(Mem, Reg8);
}

:XCHG^xacq_xrel_prefx^alwaysLock Mem,Reg16	is vexMode=0 & xacq_xrel_prefx & alwaysLock & opsize=0 & byte=0x87; Mem & Reg16 ...
{
    Reg16 = InterlockedExchange16(Mem, Reg16);
}

:XCHG^xacq_xrel_prefx^alwaysLock Mem,Reg32	is vexMode=0 & xacq_xrel_prefx & alwaysLock & opsize=1 & byte=0x87; Mem & Reg32 ...
{
    Reg32 = InterlockedExchange(Mem, Reg32);
}

@ifdef IA64
define pcodeop InterlockedExchange64;
:XCHG^xacq_xrel_prefx^alwaysLock Mem,Reg64	is $(LONGMODE_ON) & vexMode=0 & xacq_xrel_prefx & alwaysLock & opsize=2 & byte=0x87; Mem & Reg64 ...
{ 
    Reg64 = InterlockedExchange64(Mem, Reg64);
}
@endif

:XOR^lockx spec_m8,imm8      is vexMode=0 & lockx & unlock & (byte=0x80 | byte=0x82); spec_m8 & reg_opcode=6 ...; imm8     
{
    build lockx;
    build spec_m8;
    logicalflags();
    spec_m8 =   spec_m8 ^  imm8;
    resultflags(  spec_m8);
    build unlock; 
}

:XOR^lockx spec_m16,imm16    is vexMode=0 & lockx & unlock & opsize=0 & byte=0x81; spec_m16 & reg_opcode=6 ...; imm16  
{
    build lockx;
    build spec_m16;
    logicalflags();
    spec_m16 =  spec_m16 ^ imm16;
    resultflags( spec_m16);
    build unlock; 
}

:XOR^lockx spec_m32,imm32    is vexMode=0 & lockx & unlock & opsize=1 & byte=0x81; spec_m32 & reg_opcode=6 ...; imm32  
{
    build lockx;
    build spec_m32;
    logicalflags();
    spec_m32 =  spec_m32 ^ imm32;
    resultflags( spec_m32);
    build unlock; 
}

@ifdef IA64
:XOR^lockx spec_m64,simm32   is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x81; spec_m64 & reg_opcode=6 ...; simm32 
{
    build lockx;
    build spec_m64;
    logicalflags();
    spec_m64 =  spec_m64 ^ simm32;
    resultflags( spec_m64);
    build unlock; 
}
@endif

:XOR^lockx spec_m16,usimm8_16    is vexMode=0 & lockx & unlock & opsize=0 & byte=0x83; spec_m16 & reg_opcode=6 ...; usimm8_16  
{
    build lockx;
    build spec_m16;
    logicalflags();
    spec_m16 =  spec_m16 ^ usimm8_16;
    resultflags( spec_m16);
    build unlock; 
}

:XOR^lockx spec_m32,usimm8_32    is vexMode=0 & lockx & unlock & opsize=1 & byte=0x83; spec_m32 & reg_opcode=6 ...; usimm8_32  
{
    build lockx;
    build spec_m32;
    logicalflags();
    spec_m32 =  spec_m32 ^ usimm8_32;
    resultflags( spec_m32);
    build unlock; 
}

@ifdef IA64
:XOR^lockx spec_m64,usimm8_64    is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x83; spec_m64 & reg_opcode=6 ...; usimm8_64  
{
    build lockx;
    build spec_m64;
    logicalflags();
    spec_m64 =  spec_m64 ^ usimm8_64;
    resultflags( spec_m64);
    build unlock; 
}
@endif

:XOR^lockx m8,Reg8      is vexMode=0 & lockx & unlock & byte=0x30; m8 & Reg8 ...                     
{
    build lockx;
    build m8;
    logicalflags();
    m8 =   m8 ^  Reg8;
    resultflags(  m8);
    build unlock; 
}

:XOR^lockx m16,Reg16    is vexMode=0 & lockx & unlock & opsize=0 & byte=0x31; m16 & Reg16 ...        
{
    build lockx;
    build m16;
    logicalflags();
    m16 =  m16 ^ Reg16;
    resultflags( m16);
    build unlock; 
}

:XOR^lockx m32,Reg32    is vexMode=0 & lockx & unlock & opsize=1 & byte=0x31; m32 & Reg32 ... 
{
    build lockx;
    build m32;
    logicalflags();
    m32 =  m32 ^ Reg32;
    resultflags( m32);
    build unlock; 
}

@ifdef IA64
:XOR^lockx m64,Reg64    is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x31; m64 & Reg64 ...        
{
    build lockx;
    build m64;
    logicalflags();
    m64 =  m64 ^ Reg64;
    resultflags( m64);
    build unlock; 
}
@endif
