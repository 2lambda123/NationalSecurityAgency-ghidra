# 16 bit floating point support
# Ref: https://drive.google.com/file/d/1z3tQQLm5ALsAD77PM0l0CHnapxWCeVzP/view
# Note:
#    Many of these  halfword instructions are identical to their full-word equivalents (see riscv.rv32f.sinc)
#    except that funct3=0x1 instead of 0x2 or funct7 |= 0x02

# TODO: do we need an fassignH macro defined?

# Half-Precision Load Instruction
:flh frd,immI(rs1) is immI & frd & rs1 & op0001=0x3 & op0204=0x1 & op0506=0x0 & funct3=0x1
{
    local ea:$(XLEN) = immI + rs1;
    fassignS(frd, *[ram]:2 ea);
}

# Half-Precision Store Instruction
:fsh frs2S,immS(rs1) is frs2S & immS & rs1 & op0001=0x3 & op0204=0x1 & op0506=0x1 & funct3=0x1
{
	local ea:$(XLEN) = immS + rs1;
	*[ram]:2 ea = frs2S;
}

# Half-Precision Computational Instructions
:fadd.h frd,frs1S,frs2S,FRM is frs1S & frd & frs2S & FRM & op0001=0x3 & op0204=0x4 & op0506=0x2 & funct7=0x02
{
	local tmp:4 = frs1S f+ frs2S;
	fassignS(frd, tmp);
}

:fsub.h frd,frs1S,frs2S,FRM is frs1S & frd & frs2S & FRM & op0001=0x3 & op0204=0x4 & op0506=0x2 & funct7=0x6
{
	local tmp:4 = frs1S f- frs2S;
	fassignS(frd, tmp);
}

:fmul.h frd,frs1S,frs2S,FRM is frs1S & frd & frs2S & FRM & op0001=0x3 & op0204=0x4 & op0506=0x2 & funct7=0xa
{
	local tmp:4 = frs1S f* frs2S;
	fassignS(frd, tmp);
}

:fdiv.h frd,frs1S,frs2S,FRM is frs1S & frd & frs2S & FRM & op0001=0x3 & op0204=0x4 & op0506=0x2 & funct7=0xe
{
	local tmp:4 = frs1S f/ frs2S;
	fassignS(frd, tmp);
}

:fmin.h frd,frs1S,frs2S is frs1S & frd & frs2S & op0001=0x3 & op0204=0x4 & op0506=0x2 & funct3=0x0 & funct7=0x16
{
	#TODO  redo this
	local tmpfrs1 = frs1S;
	local tmpfrs2 = frs2S;
	fassignS(frd, tmpfrs1);
	if (nan(tmpfrs1) && nan(tmpfrs2)) goto inst_next;
	if (nan(tmpfrs2)) goto inst_next;
	fassignS(frd, tmpfrs2);
	if (nan(tmpfrs1)) goto inst_next;
	if (tmpfrs2 f<= tmpfrs1) goto inst_next;
	fassignS(frd, tmpfrs1);
}

:fmax.h frd,frs1S,frs2S is frs1S & frd & frs2S & op0001=0x3 & op0204=0x4 & op0506=0x2 & funct3=0x1 & funct7=0x16
{
	#TODO  redo this
	local tmpfrs1 = frs1S;
	local tmpfrs2 = frs2S;
	fassignS(frd, tmpfrs1);
	if (nan(tmpfrs1) && nan(tmpfrs2)) goto inst_next;
	if (nan(tmpfrs2)) goto inst_next;
	fassignS(frd, tmpfrs2);
	if (nan(tmpfrs1)) goto inst_next;
	if (tmpfrs2 f>= tmpfrs1) goto inst_next;
	fassignS(frd, tmpfrs1);
}

:fsqrt.h frd,frs1S,FRM is frs1S & frd & FRM & op0001=0x3 & op0204=0x4 & op0506=0x2 & funct7=0x2e & op2024=0x0
{
	local tmp:4 = sqrt(frs1S);
	fassignS(frd, tmp);
}

:fsgnj.h frd,frs1S,frs2S is frs1S & frd & frs2S & op0001=0x3 & op0204=0x4 & op0506=0x2 & funct3=0x0 & funct7=0x12
{
	local tmp:$(SFLEN) = frs1S;
	tmp[31,1] = frs2S[31,1];
	fassignS(frd, tmp);
}

:fsgnjn.h frd,frs1S,frs2S is frs1S & frd & frs2S & op0001=0x3 & op0204=0x4 & op0506=0x2 & funct3=0x1 & funct7=0x12
{
	local tmp:$(SFLEN) = frs1S;
	tmp[31,1] = !frs2S[31,1];
	fassignS(frd, tmp);
}

:fsgnjx.h frd,frs1S,frs2S is frs1S & frd & frs2S & op0001=0x3 & op0204=0x4 & op0506=0x2 & funct3=0x2 & funct7=0x12
{
	local tmp:$(SFLEN) = frs1S;
	tmp[31,1] = tmp[31,1] ^ frs2S[31,1];
	fassignS(frd, tmp);
}

:fmv.h frd,frs1S is frd & frs1S & op0001=0x3 & op0204=0x4 & op0506=0x2 & funct3=0x0 & funct7=0x12 & fr1519=fr2024
{
	fassignS(frd, frs1S);
}

:fneg.h frd,frs1S is frs1S & frd & op0001=0x3 & op0204=0x4 & op0506=0x2 & funct3=0x1 & funct7=0x12 & op1519=op2024
{
	local tmp:4 = f- frs1S;
	fassignS(frd, tmp);
}

:fabs.h frd,frs1S is frd & frs1S & op0001=0x3 & op0204=0x4 & op0506=0x2 & funct3=0x2 & funct7=0x12 & op1519=op2024
{
	local tmp:4 = abs(frs1S);
	fassignS(frd, tmp);
}

:fmadd.h frd,frs1S,frs2S,frs3S,FRM is frs1S & frd & frs2S & FRM & frs3S & op0001=0x3 & op0204=0x0 & op0506=0x2 & op2526=0x2
{
	local tmp:4 = (frs1S f* frs2S) f+ frs3S;
	fassignS(frd, tmp);
}

:fnmadd.h frd,frs1S,frs2S,frs3S,FRM is frs1S & frd & frs2S & FRM & frs3S & op0001=0x3 & op0204=0x3 & op0506=0x2 & op2526=0x2
{
	local tmp:4 = (f- (frs1S f* frs2S)) f- frs3S;
	fassignS(frd, tmp);
}

:fmsub.h frd,frs1S,frs2S,frs3S,FRM is frs1S & frd & frs2S & FRM & frs3S & op0001=0x3 & op0204=0x1 & op0506=0x2 & op2526=0x2
{
	local tmp:4 = (frs1S f* frs2S) f- frs3S;
	fassignS(frd, tmp);
}

:fnmsub.h frd,frs1S,frs2S,frs3S,FRM is frs1S & frd & frs2S & FRM & frs3S & op0001=0x3 & op0204=0x2 & op0506=0x2 & op2526=0x2
{
	local tmp:4 = (f- (frs1S f* frs2S)) f+ frs3S;
	fassignS(frd, tmp);
}

:fcvt.w.h rdW,frs1S,FRM is frs1S & FRM & rdW & op0001=0x3 & op0204=0x4 & op0506=0x2 & funct7=0x62 & op2024=0x0
{
	rdW = trunc(frs1S);
}

:fcvt.wu.h rdW,frs1S,FRM is frs1S & FRM & rdW & op0001=0x3 & op0204=0x4 & op0506=0x2 & funct7=0x62 & op2024=0x1
{
	rdW = trunc(frs1S);
}

:fcvt.h.w rdW,frs1S,FRM is frs1S & FRM & rdW & op0001=0x3 & op0204=0x4 & op0506=0x2 & funct7=0x6a & op2024=0x0
{
	rdW = frs1S;
}

:fcvt.h.wu rdW,frs1S,FRM is frs1S & FRM & rdW & op0001=0x3 & op0204=0x4 & op0506=0x2 & funct7=0x6a & op2024=0x1
{
	rdW = frs1S;
}

:fcvt.l.h rdW,frs1S,FRM is frs1S & FRM & rdW & op0001=0x3 & op0204=0x4 & op0506=0x2 & funct7=0x62 & op2024=0x02
{
	rdW = trunc(frs1S);
}

:fcvt.lu.h rdW,frs1S,FRM is frs1S & FRM & rdW & op0001=0x3 & op0204=0x4 & op0506=0x2 & funct7=0x62 & op2024=0x03
{
	rdW = trunc(frs1S);
}

:fcvt.h.l rdW,frs1S,FRM is frs1S & FRM & rdW & op0001=0x3 & op0204=0x4 & op0506=0x2 & funct7=0x6a & op2024=0x02
{
	rdW = frs1S;
}

:fcvt.h.lu rdW,frs1S,FRM is frs1S & FRM & rdW & op0001=0x3 & op0204=0x4 & op0506=0x2 & funct7=0x6a & op2024=0x03
{
	rdW = frs1S;
}

# the fmv instructions copy bits unchanged, without integer to float conversion
define pcodeop fmv_x_h;
:fmv.x.h rdW,frs1S is frs1S & rdW & op0001=0x3 & op0204=0x4 & op0506=0x2 & op2024=0x0 & funct3=0x0 & funct7=0x72 {
    rdW=fmv_x_h(frs1S);
}

define pcodeop fmv_h_x;
:fmv.h.x frd,rs1 is rs1 & frd & op0001=0x3 & op0204=0x4 & op0506=0x2 & op2024=0x0 & funct3=0x0 & funct7=0x7a {
    frd=fmv_h_x(rs1);
}

#TODO: figure out the right way to test assignments like this.
:fcvt.s.h frd,frs1S is frd & frs1S & op0001=0x3 & op0204=0x4 & op0506=0x2 & op2024=0x2 & funct7=0x20 {
	fassignS(frd, frs1S);
}

:fcvt.d.h frd,frs1S is frd & frs1S & op0001=0x3 & op0204=0x4 & op0506=0x2 & op2024=0x2 & funct7=0x21 {
	fassignS(frd, frs1S);
}

:fcvt.q.h frd,frs1S is frd & frs1S & op0001=0x3 & op0204=0x4 & op0506=0x2 & op2024=0x2 & funct7=0x23 {
	fassignS(frd, frs1S);
}

:fcvt.h.s frd,frs1S,FRM is frd & frs1S & FRM & op0001=0x3 & op0204=0x4 & op0506=0x2 & op2024=0x0 & funct7=0x22 {
    fassignS(frd, frs1S);
}

:fcvt.h.d frd,frs1S,FRM is frd & frs1S & FRM & op0001=0x3 & op0204=0x4 & op0506=0x2 & op2024=0x1 & funct7=0x22 {
    fassignS(frd, frs1S);
}

:fcvt.h.q frd,frs1S,FRM is frd & frs1S & FRM & op0001=0x3 & op0204=0x4 & op0506=0x2 & op2024=0x3 & funct7=0x22 {
    fassignS(frd, frs1S);
}

:fclass.h rd,frs1S is frs1S & rd & op0001=0x3 & op0204=0x4 & op0506=0x2 & funct3=0x1 & funct7=0x72 & op2024=0x0
{
	#TODO
	# rd = 0;
	# rd[0, 1] = 0; #TODO  - inf
	# rd[1, 1] = 0; #TODO  - norm num
	# rd[2, 1] = 0; #TODO  - subnorm num
	# rd[3, 1] = 0; #TODO  - 0
	# rd[4, 1] = 0; #TODO  + 0
	# rd[5, 1] = 0; #TODO  + norm num
	# rd[6, 1] = 0; #TODO  + subnorm num
	# rd[7, 1] = 0; #TODO  + inf
	# rd[8, 1] = 0; #TODO  snan
	# rd[9, 1] = 0; #TODO  qnan
}

:feq.h rd,frs1S,frs2S is frs2S & frs1S & rd & op0001=0x3 & op0204=0x4 & op0506=0x2 & funct3=0x2 & funct7=0x52
{
	rd = zext(frs1S f== frs2S);
}

:fle.h rd,frs1S,frs2S is frs2S & frs1S & rd & op0001=0x3 & op0204=0x4 & op0506=0x2 & funct3=0x0 & funct7=0x52
{
	rd = zext(frs1S f<= frs2S);
}

:flt.h rd,frs1S,frs2S is frs2S & frs1S & rd & op0001=0x3 & op0204=0x4 & op0506=0x2 & funct3=0x1 & funct7=0x52
{
	rd = zext(frs1S f< frs2S);
}